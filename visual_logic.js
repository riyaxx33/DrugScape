/* eslint-disable */

/**
 * Generated by Verge3D Puzzles v.4.7.1
 * Tue, 05 Nov 2024 16:31:23 GMT
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */
function createPL(v3d = window.v3d) {

// global variables used in the init tab
const _initGlob = {
    percentage: 0,
    output: {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        },
    },
};


// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.pickedObject = '';
_pGlob.hoveredObject = '';
_pGlob.mediaElements = {};
_pGlob.loadedFile = '';
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.openedFile = '';
_pGlob.openedFileMeta = {};
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();
_pGlob.intervalTimers = {};
_pGlob.customEvents = new v3d.EventDispatcher();
_pGlob.eventListeners = [];
_pGlob.htmlElements = new Set();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;
_pGlob.SET_OBJ_ROT_EPS = 1e-8;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.vec3Tmp3 = new v3d.Vector3();
_pGlob.vec3Tmp4 = new v3d.Vector3();
_pGlob.eulerTmp = new v3d.Euler();
_pGlob.eulerTmp2 = new v3d.Euler();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.colorTmp = new v3d.Color();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster(); // always check visibility

const createPzLib = ({ v3d=null, appInstance=null }) => {
    function isObjectWorthProcessing(obj) {
        return obj.type !== 'AmbientLight' && obj.name !== '' &&
                !(obj.isMesh && obj.isMaterialGeneratedMesh) &&
                !obj.isAuxClippingMesh;
    }
        
    function getObjectByName(objName) {
        let objFound = null;
    
        const pGlobAvailable = _pGlob !== undefined;
        if (pGlobAvailable && objName in _pGlob.objCache) {
            objFound = _pGlob.objCache[objName] || null;
        }
    
        if (objFound && objFound.name === objName) {
            return objFound;
        }
    
        if (appInstance.scene) {
            appInstance.scene.traverse(obj => {
                if (!objFound && isObjectWorthProcessing(obj) && (obj.name === objName)) {
                    objFound = obj;
                    if (pGlobAvailable) {
                        _pGlob.objCache[objName] = objFound;
                    }
                }
            });
        }
        return objFound;
    }
        
    function transformCoordsSpace(coords, spaceFrom, spaceTo, noSignChange=false) {
    
        if (spaceFrom === spaceTo) {
            return coords;
        }
    
        const y = coords.y;
        const z = coords.z;
    
        if (spaceFrom === 'Z_UP_RIGHT' && spaceTo === 'Y_UP_RIGHT') {
            coords.y = z;
            coords.z = noSignChange ? y : -y;
        } else if (spaceFrom === 'Y_UP_RIGHT' && spaceTo === 'Z_UP_RIGHT') {
            coords.y = noSignChange ? z : -z;
            coords.z = y;
        } else {
            console.error('transformCoordsSpace: Unsupported coordinate space');
        }
    
        return coords;
    }
        
    function getSceneCoordSystem() {
        const scene = appInstance.scene;
        if (scene && 'coordSystem' in scene.userData) {
            return scene.userData.coordSystem;
        }
    
        return 'Y_UP_RIGHT';
    }
        
    function getObjectName(obj) {
        // auto-generated from a multi-material object, use parent name instead
        if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
            return obj.parent.name;
        } else {
            return obj.name;
        }
    }
        
    function areListenersSame(target0, type0, listener0, optionsOrUseCapture0,
            target1, type1, listener1, optionsOrUseCapture1) {
        const capture0 = Boolean(optionsOrUseCapture0 instanceof Object
                ? optionsOrUseCapture0.capture : optionsOrUseCapture0);
        const capture1 = Boolean(optionsOrUseCapture1 instanceof Object
                ? optionsOrUseCapture1.capture : optionsOrUseCapture1);
        return target0 === target1 && type0 === type1 && listener0 === listener1
                && capture0 === capture1;
    }
        
    function bindListener(target, type, listener, optionsOrUseCapture) {
        const alreadyExists = _pGlob.eventListeners.some(elem => {
            return areListenersSame(elem.target, elem.type, elem.listener,
                    elem.optionsOrUseCapture, target, type, listener,
                    optionsOrUseCapture);
        });
    
        if (!alreadyExists) {
            target.addEventListener(type, listener, optionsOrUseCapture);
            _pGlob.eventListeners.push({ target, type, listener,
                    optionsOrUseCapture });
        }
    }
        
    function initObjectPicking(callback, eventType, mouseDownUseTouchStart=false,
            allowedMouseButtons=null) {
    
        const elem = appInstance.renderer.domElement;
        bindListener(elem, eventType, pickListener);
    
        if (eventType === 'mousedown') {
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, pickListener);
    
        } else if (eventType === 'dblclick') {
    
            let prevTapTime = 0;
    
            function doubleTapCallback(event) {
                const now = new Date().getTime();
                const timesince = now - prevTapTime;
    
                if (timesince < 600 && timesince > 0) {
                    pickListener(event);
                    prevTapTime = 0;
                    return;
                }
    
                prevTapTime = new Date().getTime();
            }
    
            const touchEventName = mouseDownUseTouchStart ? 'touchstart' : 'touchend';
            bindListener(elem, touchEventName, doubleTapCallback);
        }
    
        const raycaster = new v3d.Raycaster();
    
        function pickListener(event) {
    
            // to handle unload in loadScene puzzle
            if (!appInstance.getCamera()) {
                return;
            }
    
            event.preventDefault();
    
            let xNorm = 0;
            let yNorm = 0;
            if (event instanceof MouseEvent) {
                if (allowedMouseButtons !== null && allowedMouseButtons.indexOf(event.button) === -1) {
                    return;
                }
                xNorm = event.offsetX / elem.clientWidth;
                yNorm = event.offsetY / elem.clientHeight;
            } else if (event instanceof TouchEvent) {
                const rect = elem.getBoundingClientRect();
                xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
                yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
            }
    
            _pGlob.screenCoords.x = xNorm * 2 - 1;
            _pGlob.screenCoords.y = -yNorm * 2 + 1;
            raycaster.setFromCamera(_pGlob.screenCoords, appInstance.getCamera(true));
    
            const objList = [];
            appInstance.scene.traverse(obj => objList.push(obj));
    
            const intersects = raycaster.intersectObjects(objList, false);
            callback(intersects, event);
        }
    }
        
    function isObjectAmongObjects(objNameToCheck, objNames) {
        if (!objNameToCheck) {
            return false;
        }
    
        for (let i = 0; i < objNames.length; i++) {
            if (objNameToCheck === objNames[i]) {
                return true;
            } else {
                // also check children which are auto-generated for multi-material objects
                const obj = getObjectByName(objNames[i]);
                if (obj && obj.type === 'Group') {
                    for (let j = 0; j < obj.children.length; j++) {
                        if (objNameToCheck === obj.children[j].name) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }
        
    function getObjectNamesByGroupName(groupName) {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                const objGroupNames = obj.groupNames;
                if (!objGroupNames) {
                    return;
                }
    
                for (let i = 0; i < objGroupNames.length; i++) {
                    const objGroupName = objGroupNames[i];
                    if (objGroupName === groupName) {
                        objNameList.push(obj.name);
                    }
                }
            }
        });
        return objNameList;
    }
        
    function getAllObjectNames() {
        const objNameList = [];
        appInstance.scene.traverse(obj => {
            if (isObjectWorthProcessing(obj)) {
                objNameList.push(obj.name);
            }
        });
        return objNameList;
    }
        
    function retrieveObjectNamesAccum(currObjNames, namesAccum) {
        if (typeof currObjNames === 'string') {
            namesAccum.push(currObjNames);
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'GROUP') {
            const newObjNames = getObjectNamesByGroupName(currObjNames[1]);
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames) && currObjNames[0] === 'ALL_OBJECTS') {
            const newObjNames = getAllObjectNames();
            for (let i = 0; i < newObjNames.length; i++) {
                namesAccum.push(newObjNames[i]);
            }
        } else if (Array.isArray(currObjNames)) {
            for (let i = 0; i < currObjNames.length; i++) {
                retrieveObjectNamesAccum(currObjNames[i], namesAccum);
            }
        }
    }
        
    function retrieveObjectNames(objNames) {
        const accum = [];
        retrieveObjectNamesAccum(objNames, accum);
        return accum.filter(name => name !== '');
    }

    return {
        getObjectByName, transformCoordsSpace, getSceneCoordSystem, getObjectName,
        initObjectPicking, isObjectAmongObjects, retrieveObjectNames,
    };
};

var PL = {};
// backward compatibility
if (v3d[Symbol.toStringTag] !== 'Module') {
    v3d.PL = v3d.puzzles = PL;
}

PL.procedures = PL.procedures || {};




PL.execInitPuzzles = function(options) {
    // always null, should not be available in "init" puzzles
    var appInstance = null;
    // app is more conventional than appInstance (used in exec script and app templates)
    var app = null;

    const PzLib = createPzLib({ v3d });

    // provide the container's id to puzzles that need access to the container
    _initGlob.container = options !== undefined && 'container' in options
            ? options.container : "";

    

    
    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

// app is more conventional than appInstance (used in exec script and app templates)
var app = appInstance;

const PzLib = createPzLib({ v3d, appInstance });

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}



var PROC = {
    
};

var VARS = Object.defineProperties({}, {
    
});

// setActiveCamera puzzle
function setActiveCamera(camName) {
    var camera = PzLib.getObjectByName(camName);
    if (!camera || !camera.isCamera || appInstance.getCamera() == camera)
        return;
    appInstance.setCamera(camera);
}

// getActiveCamera puzzle
function getActiveCamera() {
    var camera = appInstance.getCamera();
    return camera.name;
}

// tweenCamera puzzle
function tweenCamera(posOrObj, targetOrObj, duration, doSlot, movementType) {
    var camera = appInstance.getCamera();

    if (Array.isArray(posOrObj)) {
        var worldPos = _pGlob.vec3Tmp.fromArray(posOrObj);
        worldPos = PzLib.transformCoordsSpace(worldPos,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else if (posOrObj) {
        var posObj = PzLib.getObjectByName(posOrObj);
        if (!posObj) return;
        var worldPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    } else {
        // empty input means: don't change the position
        var worldPos = camera.getWorldPosition(_pGlob.vec3Tmp);
    }

    if (Array.isArray(targetOrObj)) {
        var worldTarget = _pGlob.vec3Tmp2.fromArray(targetOrObj);
        worldTarget = PzLib.transformCoordsSpace(worldTarget,
                PzLib.getSceneCoordSystem(), 'Y_UP_RIGHT');
    } else {
        var targObj = PzLib.getObjectByName(targetOrObj);
        if (!targObj) return;
        var worldTarget = targObj.getWorldPosition(_pGlob.vec3Tmp2);
    }

    duration = Math.max(0, duration);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween) {
            appInstance.controls.tween(worldPos, worldTarget, duration, doSlot,
                    movementType);
        }
    } else {
        // TODO: static camera, just position it for now
        if (camera.parent) {
            camera.parent.worldToLocal(worldPos);
        }
        camera.position.copy(worldPos);
        camera.lookAt(worldTarget);
        doSlot();
    }
}

// whenClicked puzzle
function registerOnClick(objSelector, xRay, doubleClick, mouseButtons, cbDo, cbIfMissedDo) {

    // for AR/VR
    _pGlob.objClickInfo = _pGlob.objClickInfo || [];

    _pGlob.objClickInfo.push({
        objSelector: objSelector,
        callbacks: [cbDo, cbIfMissedDo]
    });

    PzLib.initObjectPicking(function(intersects, event) {

        var isPicked = false;

        var maxIntersects = xRay ? intersects.length : Math.min(1, intersects.length);

        for (var i = 0; i < maxIntersects; i++) {
            var obj = intersects[i].object;
            var objName = PzLib.getObjectName(obj);
            var objNames = PzLib.retrieveObjectNames(objSelector);

            if (PzLib.isObjectAmongObjects(objName, objNames)) {
                // save the object for the pickedObject block
                _pGlob.pickedObject = objName;
                isPicked = true;
                cbDo(event);
            }
        }

        if (!isPicked) {
            _pGlob.pickedObject = '';
            cbIfMissedDo(event);
        }

    }, doubleClick ? 'dblclick' : 'mousedown', false, mouseButtons);
}


setActiveCamera('Camera_Start');

registerOnClick('Door_1', false, false, [0,1,2], function() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('// Make closeDoor1Modal function global first' + '\n' +
  'window.closeDoor1Modal = function() {' + '\n' +
  '    const modal = document.getElementById(\'door1Modal\');' + '\n' +
  '    if (modal) {' + '\n' +
  '        modal.remove();' + '\n' +
  '    }' + '\n' +
  '};' + '\n' +
  '' + '\n' +
  'function showDoor1() {' + '\n' +
  '    // Create style element' + '\n' +
  '    const style = document.createElement(\'style\');' + '\n' +
  '    style.textContent = `' + '\n' +
  '        .modal-overlay {' + '\n' +
  '            position: fixed;' + '\n' +
  '            top: 0;' + '\n' +
  '            left: 0;' + '\n' +
  '            width: 100%;' + '\n' +
  '            height: 100%;' + '\n' +
  '            background-color: rgba(0, 0, 0, 0.5);' + '\n' +
  '            display: flex;' + '\n' +
  '            justify-content: center;' + '\n' +
  '            align-items: center;' + '\n' +
  '            z-index: 1000;' + '\n' +
  '        }' + '\n' +
  '' + '\n' +
  '        .modal {' + '\n' +
  '            background-color: white;' + '\n' +
  '            padding: 2rem;' + '\n' +
  '            border-radius: 10px;' + '\n' +
  '            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);' + '\n' +
  '            max-width: 400px;' + '\n' +
  '            text-align: center;' + '\n' +
  '        }' + '\n' +
  '' + '\n' +
  '        .modal h2 {' + '\n' +
  '            margin-top: 0;' + '\n' +
  '            color: #333;' + '\n' +
  '        }' + '\n' +
  '' + '\n' +
  '        .modal p {' + '\n' +
  '            color: #666;' + '\n' +
  '            line-height: 1.5;' + '\n' +
  '        }' + '\n' +
  '' + '\n' +
  '        .close-button {' + '\n' +
  '            background-color: #4CAF50;' + '\n' +
  '            color: white;' + '\n' +
  '            border: none;' + '\n' +
  '            padding: 10px 20px;' + '\n' +
  '            border-radius: 5px;' + '\n' +
  '            cursor: pointer;' + '\n' +
  '            font-size: 16px;' + '\n' +
  '            margin-top: 15px;' + '\n' +
  '        }' + '\n' +
  '' + '\n' +
  '        .close-button:hover {' + '\n' +
  '            background-color: #45a049;' + '\n' +
  '        }' + '\n' +
  '    `;' + '\n' +
  '    ' + '\n' +
  '    // Create modal HTML' + '\n' +
  '    const modalHTML = `' + '\n' +
  '        <div class="modal-overlay" id="door1Modal">' + '\n' +
  '            <div class="modal">' + '\n' +
  '                <h2>Welcome to the Void Deck!</h2>' + '\n' +
  '                <p>You need to find one question to proceed to the next room.<br>To proceed to the next room, click on the next door!</p>' + '\n' +
  '                <button class="close-button" onclick="closeDoor1Modal()">Got it!</button>' + '\n' +
  '            </div>' + '\n' +
  '        </div>' + '\n' +
  '    `;' + '\n' +
  '' + '\n' +
  '    document.head.appendChild(style);' + '\n' +
  '    document.body.insertAdjacentHTML(\'beforeend\', modalHTML);' + '\n' +
  '    ' + '\n' +
  '    const modal = document.getElementById(\'door1Modal\');' + '\n' +
  '    if (modal) {' + '\n' +
  '        modal.style.display = \'flex\';' + '\n' +
  '    }' + '\n' +
  '}' + '\n' +
  '' + '\n' +
  '// Make showDoor1 function global as well' + '\n' +
  'window.showDoor1 = showDoor1;' + '\n' +
  '' + '\n' +
  '// Call the function' + '\n' +
  'showDoor1();')))(appInstance, v3d, PL, VARS, PROC);

  setActiveCamera('Camera_R1');
  tweenCamera(getActiveCamera(), '', 5, function() {}, 0);
}, function() {});

registerOnClick('R1_Clue', false, false, [0,1,2], function() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('// Make closeClue1Modal function global first' + '\n' +
  'window.closeClue1Modal = function() {' + '\n' +
  '    const modal = document.getElementById(\'clue1Modal\');' + '\n' +
  '    if (modal) {' + '\n' +
  '        modal.remove();' + '\n' +
  '    }' + '\n' +
  '};' + '\n' +
  'function showClue1() {' + '\n' +
  '    // Create style element' + '\n' +
  '    const style = document.createElement(\'style\');' + '\n' +
  '    style.textContent = `' + '\n' +
  '        .modal-overlay {' + '\n' +
  '            position: fixed;' + '\n' +
  '            top: 0;' + '\n' +
  '            left: 0;' + '\n' +
  '            width: 100%;' + '\n' +
  '            height: 100%;' + '\n' +
  '            background-color: rgba(0, 0, 0, 0.5);' + '\n' +
  '            display: flex;' + '\n' +
  '            justify-content: center;' + '\n' +
  '            align-items: center;' + '\n' +
  '            z-index: 1000;' + '\n' +
  '        }' + '\n' +
  '        .modal {' + '\n' +
  '            background-color: white;' + '\n' +
  '            padding: 2rem;' + '\n' +
  '            border-radius: 10px;' + '\n' +
  '            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);' + '\n' +
  '            max-width: 400px;' + '\n' +
  '            text-align: center;' + '\n' +
  '        }' + '\n' +
  '        .modal h2 {' + '\n' +
  '            margin-top: 0;' + '\n' +
  '            color: #333;' + '\n' +
  '        }' + '\n' +
  '        .modal p {' + '\n' +
  '            color: #666;' + '\n' +
  '            line-height: 1.5;' + '\n' +
  '        }' + '\n' +
  '        .close-button {' + '\n' +
  '            background-color: blue;' + '\n' +
  '            color: white;' + '\n' +
  '            border: none;' + '\n' +
  '            padding: 10px 20px;' + '\n' +
  '            border-radius: 5px;' + '\n' +
  '            cursor: pointer;' + '\n' +
  '            font-size: 16px;' + '\n' +
  '            margin-top: 15px;' + '\n' +
  '        }' + '\n' +
  '        .close-button:hover {' + '\n' +
  '            background-color: #45a049;' + '\n' +
  '        }' + '\n' +
  '    `;' + '\n' +
  '    ' + '\n' +
  '    // Create modal HTML' + '\n' +
  '    const modalHTML = `' + '\n' +
  '        <div class="modal-overlay" id="clue1Modal">' + '\n' +
  '            <div class="modal">' + '\n' +
  '                <p>The punishment provision can be found in the Section 33(3A) of the MDA, which provides for an imprisonment term of not less than one year but not more than 10 years and also a fine not exceeding $20,000 (this applies only to offences after 1 April 2019)</p>' + '\n' +
  '                <button class="close-button" onclick="closeClue1Modal()">Collect</button>' + '\n' +
  '            </div>' + '\n' +
  '        </div>' + '\n' +
  '    `;' + '\n' +
  '    document.head.appendChild(style);' + '\n' +
  '    document.body.insertAdjacentHTML(\'beforeend\', modalHTML);' + '\n' +
  '    ' + '\n' +
  '    const modal = document.getElementById(\'clue1Modal\');' + '\n' +
  '    if (modal) {' + '\n' +
  '        modal.style.display = \'flex\';' + '\n' +
  '    }' + '\n' +
  '}' + '\n' +
  '// Make showClue1 function global as well' + '\n' +
  'window.showClue1 = showClue1;' + '\n' +
  '// Call the function' + '\n' +
  'showClue1();')))(appInstance, v3d, PL, VARS, PROC);

}, function() {});

registerOnClick('QR_Room1', false, false, [0,1,2], function() {

  Function('app', 'v3d', 'puzzles', 'VARS', 'PROC', (('// Define questions first' + '\n' +
  'const questions = [' + '\n' +
  '    {' + '\n' +
  '        question: "What is the minimum sentence received for consuming drugs?",' + '\n' +
  '        options: ["5", "1", "10", "Life Sentence"],' + '\n' +
  '        answer: 1,' + '\n' +
  '        explanation: "The punishment provision can be found in the Section 33(3A) of the MDA, which provides for an imprisonment term of not less than one year but not more than 10 years and also a fine not exceeding $20,000 (this applies only to offences after 1 April 2019)"' + '\n' +
  '    }' + '\n' +
  '];' + '\n' +
  '' + '\n' +
  '// Make closeQuestion1Modal function global first' + '\n' +
  'window.closeQuestion1Modal = function() {' + '\n' +
  '    const modal = document.getElementById(\'question1Modal\');' + '\n' +
  '    if (modal) {' + '\n' +
  '        modal.remove();' + '\n' +
  '    }' + '\n' +
  '};' + '\n' +
  '' + '\n' +
  'function showQuestion1() {' + '\n' +
  '    // Create style element' + '\n' +
  '    const style = document.createElement(\'style\');' + '\n' +
  '    style.textContent = `' + '\n' +
  '        .modal-overlay {' + '\n' +
  '            position: fixed;' + '\n' +
  '            top: 0;' + '\n' +
  '            left: 0;' + '\n' +
  '            width: 100%;' + '\n' +
  '            height: 100%;' + '\n' +
  '            background-color: rgba(0, 0, 0, 0.5);' + '\n' +
  '            display: flex;' + '\n' +
  '            justify-content: center;' + '\n' +
  '            align-items: center;' + '\n' +
  '            z-index: 1000;' + '\n' +
  '        }' + '\n' +
  '        .modal {' + '\n' +
  '            background-color: white;' + '\n' +
  '            padding: 2rem;' + '\n' +
  '            border-radius: 10px;' + '\n' +
  '            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);' + '\n' +
  '            max-width: 400px;' + '\n' +
  '            text-align: center;' + '\n' +
  '        }' + '\n' +
  '        .modal h2 {' + '\n' +
  '            margin-top: 0;' + '\n' +
  '            color: #333;' + '\n' +
  '        }' + '\n' +
  '        .modal p {' + '\n' +
  '            color: #666;' + '\n' +
  '            line-height: 1.5;' + '\n' +
  '        }' + '\n' +
  '        .options-container {' + '\n' +
  '            display: flex;' + '\n' +
  '            flex-direction: column;' + '\n' +
  '            gap: 10px;' + '\n' +
  '            margin: 20px 0;' + '\n' +
  '        }' + '\n' +
  '        .option-button {' + '\n' +
  '            background-color: #1E90FF;' + '\n' +
  '            color: white;' + '\n' +
  '            border: none;' + '\n' +
  '            padding: 10px 20px;' + '\n' +
  '            border-radius: 5px;' + '\n' +
  '            cursor: pointer;' + '\n' +
  '            font-size: 16px;' + '\n' +
  '        }' + '\n' +
  '        .option-button:hover {' + '\n' +
  '            background-color: #0066CC;' + '\n' +
  '        }' + '\n' +
  '        .alert-modal {' + '\n' +
  '            z-index: 1001;' + '\n' +
  '        }' + '\n' +
  '        .alert-modal .modal {' + '\n' +
  '            background-color: white;' + '\n' +
  '            padding: 1.5rem;' + '\n' +
  '            max-width: 300px;' + '\n' +
  '        }' + '\n' +
  '        .try-again-button {' + '\n' +
  '            background-color: #FF0000;' + '\n' +
  '            color: white;' + '\n' +
  '            border: none;' + '\n' +
  '            padding: 10px 20px;' + '\n' +
  '            border-radius: 5px;' + '\n' +
  '            cursor: pointer;' + '\n' +
  '            font-size: 16px;' + '\n' +
  '        }' + '\n' +
  '        .try-again-button:hover {' + '\n' +
  '            background-color: #CC0000;' + '\n' +
  '        }' + '\n' +
  '        .xp-button {' + '\n' +
  '            background-color: #4CAF50;' + '\n' +
  '            color: white;' + '\n' +
  '            border: none;' + '\n' +
  '            padding: 10px 20px;' + '\n' +
  '            border-radius: 5px;' + '\n' +
  '            cursor: pointer;' + '\n' +
  '            font-size: 16px;' + '\n' +
  '            float: right;' + '\n' +
  '        }' + '\n' +
  '        .xp-button:hover {' + '\n' +
  '            background-color: #45a049;' + '\n' +
  '        }' + '\n' +
  '    `;' + '\n' +
  '    ' + '\n' +
  '    const questionIndex = 0; // For the first question' + '\n' +
  '    const question = questions[questionIndex];' + '\n' +
  '    ' + '\n' +
  '    // Create modal HTML' + '\n' +
  '    const modalHTML = `' + '\n' +
  '        <div class="modal-overlay" id="question1Modal">' + '\n' +
  '            <div class="modal" onclick="event.stopPropagation()">' + '\n' +
  '                <h2>Question 1</h2>' + '\n' +
  '                <p>${question.question}</p>' + '\n' +
  '                <div class="options-container">' + '\n' +
  '                    ${question.options.map((option, index) => `' + '\n' +
  '                        <button class="option-button" onclick="checkQuestion1Answer(event, ${index}, ${questionIndex})">${option}</button>' + '\n' +
  '                    `).join(\'\')}' + '\n' +
  '                </div>' + '\n' +
  '            </div>' + '\n' +
  '        </div>' + '\n' +
  '    `;' + '\n' +
  '    ' + '\n' +
  '    document.head.appendChild(style);' + '\n' +
  '    document.body.insertAdjacentHTML(\'beforeend\', modalHTML);' + '\n' +
  '    ' + '\n' +
  '    const modal = document.getElementById(\'question1Modal\');' + '\n' +
  '    if (modal) {' + '\n' +
  '        modal.style.display = \'flex\';' + '\n' +
  '        modal.addEventListener(\'click\', function(e) {' + '\n' +
  '            if (e.target === modal) {' + '\n' +
  '                closeQuestion1Modal();' + '\n' +
  '            }' + '\n' +
  '        });' + '\n' +
  '    }' + '\n' +
  '}' + '\n' +
  '' + '\n' +
  '// Function to show custom alert' + '\n' +
  'function showCustomAlert(message, isCorrect) {' + '\n' +
  '    const alertHTML = `' + '\n' +
  '        <div class="modal-overlay alert-modal" id="alertModal">' + '\n' +
  '            <div class="modal" onclick="event.stopPropagation()">' + '\n' +
  '                <h2>${isCorrect ? \'Correct!\' : \'Incorrect\'}</h2>' + '\n' +
  '                <p>${message}</p>' + '\n' +
  '                <button class="${isCorrect ? \'xp-button\' : \'try-again-button\'}" onclick="closeAlertModal(${isCorrect})">' + '\n' +
  '                    ${isCorrect ? \'+100 XP\' : \'Try Again\'}' + '\n' +
  '                </button>' + '\n' +
  '            </div>' + '\n' +
  '        </div>' + '\n' +
  '    `;' + '\n' +
  '    document.body.insertAdjacentHTML(\'beforeend\', alertHTML);' + '\n' +
  '}' + '\n' +
  '' + '\n' +
  '// Function to close alert modal' + '\n' +
  'window.closeAlertModal = function(isCorrect) {' + '\n' +
  '    const alertModal = document.getElementById(\'alertModal\');' + '\n' +
  '    if (alertModal) {' + '\n' +
  '        alertModal.remove();' + '\n' +
  '    }' + '\n' +
  '    if (isCorrect) {' + '\n' +
  '        closeQuestion1Modal();' + '\n' +
  '    }' + '\n' +
  '};' + '\n' +
  '' + '\n' +
  '// Function to check answers' + '\n' +
  'window.checkQuestion1Answer = function(event, selectedIndex, questionIndex) {' + '\n' +
  '    // Prevent event bubbling' + '\n' +
  '    event.stopPropagation();' + '\n' +
  '    ' + '\n' +
  '    const question = questions[questionIndex];' + '\n' +
  '    if (selectedIndex === question.answer) {' + '\n' +
  '        showCustomAlert(question.explanation, true);' + '\n' +
  '    } else {' + '\n' +
  '        showCustomAlert("Wrong answer. Please try again.", false);' + '\n' +
  '    }' + '\n' +
  '};' + '\n' +
  '' + '\n' +
  '// Make showQuestion1 function global as well' + '\n' +
  'window.showQuestion1 = showQuestion1;' + '\n' +
  '' + '\n' +
  '// Call the function' + '\n' +
  'showQuestion1();')))(appInstance, v3d, PL, VARS, PROC);

}, function() {});



} // end of PL.init function

PL.disposeListeners = function() {
    if (_pGlob) {
        _pGlob.eventListeners.forEach(({ target, type, listener, optionsOrUseCapture }) => {
            target.removeEventListener(type, listener, optionsOrUseCapture);
        });
        _pGlob.eventListeners.length = 0;
    }
}

PL.disposeHTMLElements = function() {
    if (_pGlob) {
        _pGlob.htmlElements.forEach(elem => {
            elem.remove();
        });
        _pGlob.htmlElements.clear();
    }
}

PL.dispose = function() {
    PL.disposeListeners();
    PL.disposeHTMLElements();
    _pGlob = null;
    // backward compatibility
    if (v3d[Symbol.toStringTag] !== 'Module') {
        delete v3d.PL;
        delete v3d.puzzles;
    }
}



return PL;

}

export { createPL };
